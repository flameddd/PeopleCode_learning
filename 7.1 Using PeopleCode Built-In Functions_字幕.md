7, using PeopleCode Built-In Functions. Our objectives, by the end of this lesson, you'll be able to list the types of PeopleCode built-in functions, explain message catalog functions, describe the All, None, and PriorValue functions, explain string functions, identify other built-in functions, and identify reserved words.

Categories of PeopleCode built-in functions. PeopleCode includes numerous categories of built-in functions, including, but not limited to component buffer functions. So component buffer functions are used to modify fields, records, rows, and rows sets within the component buffer. These functions can update the value of a field, hide of field, or retrieve the value of a field for other processing. Examples would be GetField, CreateRowset, GetRow, InsertRow, those would be examples.

We have date and time functions. They're used to calculate and manipulate dates easily. We can use things like days between, would be an example of a function that we could use. We have internet functions that are used for working with internet scripts and browsers, such as encoding URLs or viewing URLs or working with iScripts. We have logical functions. Logical functions are used to check if values exist for a field. So an example would be All or None would be used to check to see if there is a value in a field.

We have message catalog functions to be able to retrieve messages from the message catalog. So we can do things like MsgGet, or MsgGetText. We have a number of functions to manipulate numeric values, so you could use things like IsNumber to find out if the field is a number. We have object-oriented functions. They're used to instantiate objects, things such as GetChart, GetRecord, GetField would be examples of them.

We have string functions. They manipulate character strings. You could be converting a string to a number or vice versa, or maybe doing a concatenate or you could do a substring or a right trim. PeopleCode includes built-in in functions also that are used for fluid applications, like AddStyleSheet or IsFluidMode.

Explaining message catalog functions, the message catalog provides a central place to create and maintain messages rather than hard coding them into your PeopleCode program. It allows you to reuse and share messages among programs, facilitates translations, and messages are stored and maintained in a message catalog by message set number and message number. So you learned in PeopleSoft PeopleTools 2 that message catalog has lots of advantages. Again, I can create a message and create it once and use it over and over and over in different places. If I ever need to make a change to it, I only have to change it in that one location.

Well, another advantage of the message catalog would be the fact that I can go out there and have it translated for different languages that I might want to use. So when we look at the message catalog, you learned about this when you took the class PeopleTools Part 2, but if I go over to our training environment and I go to the PIA to get to the message catalog, we'd go to the Nav bar, the Navigator, go to our root level of the menu, go to our PeopleTools folder, go into our Utilities, Administration, and Message Catalog.

And the message catalog is exactly what it sounds like. It's a place where we store messages. And we have a message set. Message set is a way of organizing messages. So notice we got Message Set number 2 is for PeopleCode. So when I look in here, I can see messages that are used in PeopleCode-- 817 of them. So here's an example of one that has the severity of error invalid use of exclamation point. And you see a description.

When we look at it, you have the message set is going to be a way of grouping messages out here. You have the description of the message, the short description of the message, and then you see down below the message number. So with the message number here is a unique identifier of a message within the set, and then you have a severity. The severity field in the message catalog is for a message box. So message box uses the severity to determine and tell the processor how to handle the delivery. So notice here, you see this one is set up as Error. We have Cancel. We have Message. We have Warning.

We can use PeopleCode to be able to access messages from the message catalog, so we have one function called the MsgGet, retrieves a message from the message catalog. With the MsgGet, get we tell it the message set, the message number, and then a default message text in case we can't find the message in the message catalog. Maybe someone deleted it or maybe it did not get created in this environment.

MsgGet ignores the severity defined in the message catalog. You can specify the severity in the PeopleCode program. For example, by using MsgGet as an argument to an error or a warning statement. If we take a look at the example, if I go back to our training environment and let's say we go back to that PSU course session component, and go back into its PeopleCode that we have out here.

So I'll say View the PeopleCode. And if we look at the Save Edit function here, we looked at this one earlier. We said if there is a value, if All inside this PSU course session start date and PSU course session end date, and the PSU course session start date is greater than the PSU course session end date, then we did an error. We said error is a message that stops the processing, gives a message to the user. And then you see here we're using the MsgGet function. With the MsgGet function, we're saying go to the Message Catalog, go to message 1040.

So if I come over here and I say let's return to Search and look at message 1040, then it said to use message number 3. So if I come back over here and go down to message number 3, here it says course start date, and notice it says %1 here. It's in parentheses. You don't have to have the parentheses, but %1 is a bind variable. So we can pass parameters from our PeopleCode into the message set. It says course start date, bind variable 1 must not be later than course end day bind variable 2.

And if we come back over here to our Application Designer, here we said Use Message 1040 Message 3. If we didn't find the message, we wanted to say Message not found. Course start date must not be later than end date. But this message will only be displayed if we cannot find the message 1040 message 3. If we find 1043, it'll pass these parameters into the message text in the message catalog. So, and it passes them in the order in which we have listed. So course session start date would be passed into bind parameter 1, %1, course session end date would be passed into bind variable 2, %2.

You can also use a MsgGet text and MessageBox. with a MsgGet and a MsgGetText, the always, the severity type always be a type Message when you're using them. With MessageBox, we use the severity that's set up in the Message Catalog, but with MsgGet and MsgGetText, we use PeopleCode to set the severity. The message that I get, Text and MessageBox functions to retrieve messages from the Message Catalog. The MessageBox function retrieves messages from the Message Catalog, but it provides the flexibility to determine which buttons are going to be displayed.

So with a MessageBox, you have a style. Cadillac, Cadillac style. No, no, I mean, that's a different type style. But we have a style. And what a style is, is a number that we can send it to tell it what buttons we want to give in our message box. So a style of a 0 you get an OK button. Style of a 1 you get an OK button and a Cancel button. Style of a 2, you get an Abort, a Reentry and an Ignore button. Style of a-- I'm sorry, that's a 2. A style of a 3 gets a Yes, a No, and a Cancel button. Style of a 4 gets a Yes button and a No button. Style of a 5 gets a Reentry and a Cancel button. So we have styles that we can send with the Message Box.

After the Style, then you see the Title. So the Title is, the text is going to appear in the Message Box. If we don't specify a title, then PeopleTools provides the appropriate value for us. And then you have the Message Set Number from the Message Catalog, the Message Number and the Default Message. And then after the Default Message, just like the MsgGet, you can go out and pass the parameters.

MsgGetText function is similar to a MsgGet function, except that the Message Set and Message Numbers do not appear following the text of the message. So when you do a MsgGet, when the user gets them, for example, the error in the previous example, at the end of it, it said this was Message 1040, Message 3. If you did a MsgGetText, it would not tell you what the Message Number was that came from the Catalog. It just gives you the message.

So here we can see the style, we see the title. Restrictions on the use of Message Box and PeopleSoft Pure Internet Architecture, the title is only required, is required by the function, but it will be ignored at runtime. So you can use the double quotes instead. Any developer-defined icon or default button action will be ignored at runtime. The warning icon and exclamation point inside a triangle will be used. Any developer-defined style characteristics for number and type of buttons will be ignored if the severity of the message is specified in the Message Catalog, Error Warning, or Cancel.

MessageBox is used with a severity of message. You can specify the number and the type of button. So I was talking about the style telling you which buttons you're going to get, you're also going to have a Return code. In addition, you can catch a Return Values for branching in your code. If it returns a 0, that means that the user got a warning. If it returns a 1, an OK button was pressed. A 2 would be a Cancel button pressed. 3 would mean the Abort button was pressed. 4 would mean a Retry button was pressed, 5 would be Ignore button press. 6 would be the Yes button, and 7 would be the No button. And, of course, which buttons that could be returned is based upon what style that you gave them.

So if I set up the style of a 2, which would mean you could have Abort, a Reentry and Ignore, then they could return a 3 for Abort, an option of a 5 for Ignore, or a option of a 4 for Retry, or Reentry. Here's an example here. You see we got a constant Yes and a constant No. Constant Yes is equal to 6, and constant No is equal to 7. Well, that's the buttons that would be-- or not the buttons, but the return values that would be pressed. Here they said &response equals MessageBox, and they said use %MessageStyle Yes, No. They could have just went in and said use a MessageStyle of a 4, and that would have done the same thing.

Told it to use message 21000, message 1, message Not Found. A response is equal to @Yes, which would mean it was a-- if that was the response coming back was a number of a 6, then the user said Yes. If Else, that means they must have hit the No button, which would be a 7.

All, None, and PriorValue functions. All and None functions check for the existence or the non-existence of a value in a field, a variable. All returns True as long as all the fields that it's checking has a value in it. None returns True as long as the fields it is checking does not have a value within it. We also have PriorValue function. Can be used to retrieve the value of a field just before it's changed. So you can say PriorValue, and then the field name. You use this only in FieldEdit or FieldChange. Here it talks about AllOrNone. What constitutes a value? Character fields would be an empty string or space, number would be 0. Anything else would be Null would mean lack of a value.

These functions are generally referenced within an If block. So we're checking to see if we want to go do something. And we've looked at that a couple of times already. Derivatives of it, we have AllOrNone, OnlyOne and OnlyOneOrNone functions. AllOrNone, this function returns True if either all fields in the set have values, or no fields in the set have values. OnlyOne, this function returns True if exactly one field in a set has a value. OnlyOneOrNone, this function returns True if no more than one field in a set has a value.

So here's kind of example of some code that we have where we're saying IfAll, and then we have the set is pulling the PSU task table start date and the PSU task end date. So there's a value in both of those dates. If they're not null, then set the variable project time to be the task table's end time minus the task table start time. Else, you get a error message Get and tell it to go to the Message Catalog.

PriorValue function, use the PriorValue function in Field Edit and Field Change Events only, because it evaluates to a valid value only during these events. Using the Function and Other Events returns the field's current value. Note these additional restrictions on the use of PriorValue. some functions like None do not allow you to next a call to PriorValue. You must first assign it to a variable. If you pass any field other than the one that the program is attached to, then it will return the current value of the other field. So be careful, young grasshopper.